# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Filter a matrix based on a threshold value
#'
#' This function filters an input matrix based on a threshold value. Values below
#' the threshold are set to 0. For each row this function calculates \code{max(row)}.
#' The actual threshold used for filtering is \code{min(threshold, max(row))}. This guarantees that
#' there is always at least one non-zero value in each row. WARNING: the input matrix is modified
#' in-place.
#'
#' @param m The input matrix
#' @param treshold The threhsold used for filtering. See Description for details
#' @return This function does not return any value. The input matrix is modified in-place.
#'
#'
filter_matrix <- function(m, threshold) {
    invisible(.Call('_vite_filter_matrix', PACKAGE = 'vite', m, threshold))
}

#' Filter a matrix based on the rank of the values in each row
#'
#' This function filters an input matrix, by ranking the data in each row from largest to smallest,
#' and setting any element whose rank is greater than the input threshold to 0. In other words,
#' if the treshold is X, only the X greatest values in each row will be kept, and the rest will
#' be set to 0. WARNING: the input matrix is modified in-place.
#'
#' @param m The input matrix
#' @param threshold The threshold rank. Values with rank greater than the threhsold will be set to
#'   0. Note that the rank is 1-based (i.e. the largest observation has rank 1)
#' @return This function does not return any value. The input matrix is modified in-place.
#' @export
#'
filter_matrix_by_rank <- function(m, threshold) {
    invisible(.Call('_vite_filter_matrix_by_rank', PACKAGE = 'vite', m, threshold))
}

layout_forceatlas2Cpp <- function(lay, F_att_orig, mass, nodes_size, edge_list, avg_displ, kgrav, iter, prevent_overlap, fixed, max_displ, stopping_tolerance, barnes_hut) {
    invisible(.Call('_vite_layout_forceatlas2Cpp', PACKAGE = 'vite', lay, F_att_orig, mass, nodes_size, edge_list, avg_displ, kgrav, iter, prevent_overlap, fixed, max_displ, stopping_tolerance, barnes_hut))
}

